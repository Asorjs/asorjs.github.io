import { MagicStringAST, SFC } from '@vue-macros/common';
export * from '@vue-macros/common';
export { SFC, parseSFC } from '@vue-macros/common';
import { TypeScript, Declaration, Statement, TSModuleBlock, TSType, TSParenthesizedType, TSTypeAliasDeclaration, Node, Identifier, TSCallSignatureDeclaration, TSFunctionType, TSConstructSignatureDeclaration, TSMethodSignature, TSPropertySignature, TSMappedType, TSInterfaceDeclaration, TSInterfaceBody, TSTypeLiteral, TSIntersectionType, TemplateLiteral, StringLiteral, TSLiteralType, NumericLiteral, BooleanLiteral, BigIntLiteral, TSTypeElement, TSIndexedAccessType, TSUnionType, TSTypeOperator, CallExpression, LVal, VariableDeclaration, ExpressionStatement, TSTypeReference, ObjectMethod, ObjectProperty, Expression } from '@babel/types';
import { PluginContext } from 'rollup';
import { Plugin } from 'vite';

type TSDeclaration = TypeScript & Declaration;
declare function isTSDeclaration(node: any): node is TSDeclaration;

interface TSScopeBase {
    exports?: TSNamespace;
    declarations?: TSNamespace;
}
interface TSFile extends TSScopeBase {
    kind: 'file';
    filePath: string;
    content: string;
    /** could be undefined if it's a JSON file */
    ast: Statement[] | undefined;
}
interface TSModule extends TSScopeBase {
    kind: 'module';
    ast: TSModuleBlock;
    scope: TSScope;
}
type TSScope = TSFile | TSModule;
declare const tsFileCache: Record<string, TSFile>;
declare function getTSFile(filePath: string): Promise<TSFile>;
interface ResolvedTSScope {
    isFile: boolean;
    file: TSFile;
    body: Statement[] | undefined;
    exports?: TSNamespace;
    declarations?: TSNamespace;
}
declare function resolveTSScope(scope: TSScope): ResolvedTSScope;

interface TSResolvedType<T = Exclude<TSType, TSParenthesizedType> | Exclude<TSDeclaration, TSTypeAliasDeclaration>> {
    scope: TSScope;
    type: T;
}
type TSReferencedType = TSType | Identifier | TSDeclaration;
declare function isSupportedForTSReferencedType(node: Node): node is TSReferencedType;
/**
 * Resolve a reference to a type.
 *
 * Supports `type` and `interface` only.
 *
 * @limitation don't support non-TS declaration (e.g. class, function...)
 */
declare function resolveTSReferencedType(ref: TSResolvedType<TSReferencedType>, stacks?: TSResolvedType<any>[]): Promise<TSResolvedType | TSNamespace | undefined>;

declare const namespaceSymbol: unique symbol;
type TSNamespace = {
    [K in string]: TSResolvedType | TSNamespace | undefined;
} & {
    [namespaceSymbol]: true;
};
declare function isTSNamespace(val: unknown): val is TSNamespace;
/**
 * Get exports of the TS file.
 *
 * @limitation don't support non-TS declaration (e.g. class, function...)
 */
declare function resolveTSNamespace(scope: TSScope): Promise<void>;

interface TSProperties {
    callSignatures: Array<TSResolvedType<TSCallSignatureDeclaration | TSFunctionType>>;
    constructSignatures: Array<TSResolvedType<TSConstructSignatureDeclaration>>;
    methods: Record<string | number, Array<TSResolvedType<TSMethodSignature>>>;
    properties: Record<string | number, {
        value: TSResolvedType<TSType> | null;
        optional: boolean;
        signature: TSResolvedType<TSPropertySignature | TSMappedType>;
    }>;
}
declare function mergeTSProperties(a: TSProperties, b: TSProperties): TSProperties;
declare function checkForTSProperties(node?: Node): node is TSInterfaceDeclaration | TSInterfaceBody | TSTypeLiteral | TSIntersectionType | TSMappedType | TSFunctionType;
/**
 * get properties of `interface` or `type` declaration
 *
 * @limitation don't support index signature
 */
declare function resolveTSProperties({ type, scope, }: TSResolvedType<TSInterfaceDeclaration | TSInterfaceBody | TSTypeLiteral | TSIntersectionType | TSMappedType | TSFunctionType>): Promise<TSProperties>;
declare function getTSPropertiesKeys(properties: TSProperties): string[];

type ResolveTSFileIdImpl = (id: string, importer: string) => Promise<string | undefined> | string | undefined;
declare const resolveTSFileId: ResolveTSFileIdImpl;
/**
 * @limitation don't node_modules and JavaScript file
 */
declare const resolveTSFileIdNode: ResolveTSFileIdImpl;
declare function setResolveTSFileIdImpl(impl: ResolveTSFileIdImpl): void;

declare function resolveTSTemplateLiteral({ type, scope, }: TSResolvedType<TemplateLiteral>): Promise<StringLiteral[]>;
declare function resolveTSLiteralType({ type, scope, }: TSResolvedType<TSLiteralType>): Promise<StringLiteral[] | NumericLiteral | StringLiteral | BooleanLiteral | BigIntLiteral | undefined>;
/**
 * @limitation don't support index signature
 */
declare function resolveTypeElements(scope: TSScope, elements: Array<TSTypeElement>): TSProperties;
declare function resolveTSIndexedAccessType({ scope, type }: TSResolvedType<TSIndexedAccessType>, stacks?: TSResolvedType<any>[]): Promise<{
    type: TSUnionType;
    scope: TSScope;
} | undefined>;
declare function resolveTSTypeOperator({ scope, type }: TSResolvedType<TSTypeOperator>, stacks?: TSResolvedType<any>[]): Promise<StringLiteral[] | undefined>;
declare function resolveMaybeTSUnion<T extends Node>(node: T | T[]): T[];
declare function resolveMaybeTSUnion<T extends Node>(node: T): (T | TSType)[];

declare enum DefinitionKind {
    /**
     * Definition is a referenced variable.
     *
     * @example defineSomething(foo)
     */
    Reference = "Reference",
    /**
     * Definition is a `ObjectExpression`.
     *
     * @example defineSomething({ ... })
     */
    Object = "Object",
    /**
     * Definition is TypeScript interface.
     *
     * @example defineSomething<{ ... }>()
     */
    TS = "TS"
}
interface ASTDefinition<T extends Node> {
    code: string;
    scope: TSFile | TSModule | undefined;
    ast: T;
}

declare function handleTSEmitsDefinition({ s, file, offset, defineEmitsAst, typeDeclRaw, declId, statement, }: {
    s: MagicStringAST;
    file: TSFile;
    sfc: SFC;
    offset: number;
    defineEmitsAst: CallExpression;
    typeDeclRaw: TSType;
    statement: DefineEmitsStatement;
    declId?: LVal;
}): Promise<TSEmits>;
type Emits = TSEmits | undefined;
type DefineEmitsStatement = VariableDeclaration | ExpressionStatement;
interface EmitsBase {
    declId?: LVal;
    statementAst: DefineEmitsStatement;
    defineEmitsAst: CallExpression;
}
interface TSEmits extends EmitsBase {
    kind: DefinitionKind.TS;
    definitions: Record<string, ASTDefinition<TSCallSignatureDeclaration | TSFunctionType | TSPropertySignature | TSMappedType>[]>;
    definitionsAst: ASTDefinition<TSTypeLiteral | TSIntersectionType | TSInterfaceDeclaration | TSFunctionType>;
    /**
     * Adds a new emit to the definitions. `definitions` will updated after this call.
     *
     * Added definition cannot be set and removed again.
     *
     * @example add('change', '(evt: "change", value: string): void')
     */
    addEmit: (name: string | StringLiteral, signature: string) => void;
    /**
     * Modify a definition of a emit. `definitions` will updated after this call.
     *
     * @limitation Cannot set the emit added by `addEmit`.
     *
     * @example setEmit('foo', 0, '(evt: "change", value: string): void')
     *
     * @returns false if the definition does not exist.
     */
    setEmit: (name: string | StringLiteral, index: number, signature: string) => boolean;
    /**
     * Removes specified emit from TS interface. `definitions` will updated after this call.
     *
     * @limitation Cannot remove emit added by `addEmit`. (it will be removed in definitions though)
     *
     * @returns `true` if emit was removed, `false` if emit was not found.
     */
    removeEmit: (name: string | StringLiteral, index: number) => boolean;
}

declare function handleTSPropsDefinition({ s, file, offset, definePropsAst, typeDeclRaw, withDefaultsAst, defaultsDeclRaw, statement, declId, }: {
    s: MagicStringAST;
    file: TSFile;
    sfc: SFC;
    offset: number;
    definePropsAst: CallExpression;
    typeDeclRaw: TSType;
    withDefaultsAst?: CallExpression;
    defaultsDeclRaw?: DefaultsASTRaw;
    statement: DefinePropsStatement;
    declId?: LVal;
}): Promise<TSProps>;
type Props = /* ReferenceProps | ObjectProps | */ TSProps | undefined;
type DefinePropsStatement = VariableDeclaration | ExpressionStatement;
type DefaultsASTRaw = CallExpression['arguments'][number];
interface PropsBase {
    declId?: LVal;
    statementAst: DefinePropsStatement;
    definePropsAst: CallExpression;
    withDefaultsAst?: CallExpression;
}
interface TSPropsMethod {
    type: 'method';
    methods: ASTDefinition<TSMethodSignature>[];
    optional: boolean;
}
interface TSPropsProperty {
    type: 'property';
    value: ASTDefinition<TSResolvedType['type']> | undefined;
    optional: boolean;
    signature: ASTDefinition<TSPropertySignature | TSMappedType>;
    /** Whether added by `addProp` API */
    addByAPI: boolean;
}
interface RuntimePropDefinition {
    type: string[];
    required: boolean;
    default?: (key?: string) => string;
}
interface TSProps extends PropsBase {
    kind: DefinitionKind.TS;
    definitions: Record<string | number, TSPropsMethod | TSPropsProperty>;
    definitionsAst: ASTDefinition<TSInterfaceDeclaration | TSTypeLiteral | TSIntersectionType | TSUnionType | TSMappedType | TSTypeReference>;
    /**
     * Default value of props.
     *
     * `undefined` if not defined or it's not a static expression that cannot be analyzed statically.
     */
    defaults?: Record<string, ObjectMethod | ObjectProperty>;
    /**
     * `undefined` if not defined.
     */
    defaultsAst?: Expression;
    /**
     * Adds a new prop to the definitions. `definitions` will updated after this call.
     *
     * Added definition cannot be set and removed again.
     *
     * @example addProp('foo', 'string ｜ boolean')
     *
     * @returns false if the definition already exists.
     */
    addProp: (name: string | StringLiteral, type: string, optional?: boolean) => boolean;
    /**
     * Modify a definition of a prop. `definitions` will updated after this call.
     *
     * @limitation Cannot set the prop added by `addProp`.
     *
     * @example setProp('foo', 'string ｜ boolean')
     *
     * @returns false if the definition does not exist.
     */
    setProp: (name: string | StringLiteral, type: string, optional?: boolean) => boolean;
    /**
     * Removes specified prop from TS interface. `definitions` will updated after this call.
     *
     * @limitation Cannot remove prop added by `addProp`. (it will be removed in definitions though)
     *
     * @returns `true` if prop was removed, `false` if prop was not found.
     */
    removeProp: (name: string | StringLiteral) => boolean;
    /**
     * get runtime definitions.
     */
    getRuntimeDefinitions: () => Promise<Record<string, RuntimePropDefinition>>;
}

interface AnalyzeResult {
    props: Props;
    emits: Emits;
}
declare function analyzeSFC(s: MagicStringAST, sfc: SFC): Promise<AnalyzeResult>;

declare const UNKNOWN_TYPE = "Unknown";
declare function inferRuntimeType(node: TSResolvedType | TSNamespace): Promise<string[]>;
declare function attachNodeLoc(node: Node, newNode: Node): void;
declare function genRuntimePropDefinition(types: string[] | undefined, isProduction: boolean, properties: string[]): string;

declare const deepImportRE: RegExp;
declare const RollupResolve: () => {
    resolve: (ctx: PluginContext) => ResolveTSFileIdImpl;
    handleHotUpdate: NonNullable<Plugin["handleHotUpdate"]>;
};

export { type ASTDefinition, type AnalyzeResult, type DefaultsASTRaw, type DefineEmitsStatement, type DefinePropsStatement, DefinitionKind, type Emits, type EmitsBase, type Props, type PropsBase, type ResolveTSFileIdImpl, RollupResolve, type RuntimePropDefinition, type TSDeclaration, type TSEmits, type TSFile, type TSModule, type TSNamespace, type TSProperties, type TSProps, type TSPropsMethod, type TSPropsProperty, type TSResolvedType, type TSScope, type TSScopeBase, UNKNOWN_TYPE, analyzeSFC, attachNodeLoc, checkForTSProperties, deepImportRE, genRuntimePropDefinition, getTSFile, getTSPropertiesKeys, handleTSEmitsDefinition, handleTSPropsDefinition, inferRuntimeType, isSupportedForTSReferencedType, isTSDeclaration, isTSNamespace, mergeTSProperties, namespaceSymbol, resolveMaybeTSUnion, resolveTSFileId, resolveTSFileIdNode, resolveTSIndexedAccessType, resolveTSLiteralType, resolveTSNamespace, resolveTSProperties, resolveTSReferencedType, resolveTSScope, resolveTSTemplateLiteral, resolveTSTypeOperator, resolveTypeElements, setResolveTSFileIdImpl, tsFileCache };
